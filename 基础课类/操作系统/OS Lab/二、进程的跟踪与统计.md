# 进程运行轨迹的跟踪与统计

## 内容复习

### 需要掌握哪些知识？

- 线程与进程的区别？
- 用户栈与内核栈的区别？用户栈、内核栈切换的实现？
- 内核态线程的生命周期五段论？
- 内核级线程的启动与切换？
- Linux的进程调度算法？

- 多进程的同步与信号量？
- 信号量的临界区保护？

#### 线程与进程

​	线程可以认为是轻量级的进程，多个线程是共享同一套内存空间的；因此线程之间的切换并不需要切换页表，只需要切换栈指针与PC即可

#### 用户栈与内核栈

​	内核栈是用于OS进行系统调用时的栈，该栈会在中断时自动切换（即触发中断就自动切换）。切换的原理是在切入内核栈的时候就会保存所有有关的寄存器的值（包括rsp），相当于在内核栈与用户栈之间拉了一条“线”，并在进出内核的时候通过这层关系进行状态切换。

- 用户级线程的切换事实上就是用户栈的切换，切换函数如下

```c
void yield(Thread* threadSrc, Thread* threadDst) {
    __int64_t src_rsp;
    __int64_t dst_rsp;
    asm volatile("movq %%rsp, %0" : "=a"(src_rsp));
    threadSrc->rsp = src_rsp;
    dst_rsp = threadDst->rsp;
    asm volatile("movq %0, %%rsp" ::"a"(dst_rsp));
    return;
}
//并不需要修改PC的值的原因是，将目标线程的下一条语句放入了自己的返回栈中，因此在ret的时候自动修改了PC的值
```

- 内核级线程的切换事实上就是内核栈的切换（内核栈切换会带来用户栈的切换，因此实际上用户栈和内核栈都切换了）；实现的原理是先类似于上面用户栈切换的方式切换内核栈，再利用目标内核栈的iret语句将内核栈中的ss:sp、cs:ip部分恢复入寄存器中，从而退出后切换到了目标线程的用户态中

#### 内核线程五段论

- 触发中断，陷入内核
- 中断处理函数触发调度
- 调度选择出目的进程
- 切换到目的线程（切换内核栈，使得返回的目的地是目标线程的用户态）
- 退出中断（iret返回用户态）

#### 进程的启动

​	新建一个PCB，复制父进程的数据（内核栈要新建，用户栈可以共用），将对应返回值改为0；并将新的内核栈做成可以切换并返回到用户态的样子。将PCB加入就绪队列中，等待进程调度算法唤醒。

#### Linux进程调度算法

​	循环遍历任务链表，找出当前counter最大的就绪态任务，并切换到这个任务。如果没有找到合适的counter（没有任务是就绪态），那么一方面需要等待，另一方面需要让这些阻塞态任务比之后加进来的就绪态任务有更高的优先级，因此更新所有列表中任务的counter，直到等到有就绪态任务出现，则退出循环并切换。

#### 信号量与进程同步

​	信号量是Dijkstra提出的一种整型变量，它记录了同步的多方的共用资源数量，从而达到多个进程的同步。

> 可以假设满足如下的规律：
>
> - 信号量sem记录了当前buffer能提供的空闲量
> - 如果有一个生产者进程对buffer有需求而未得到满足，则sem-=1
> - 如果sem为负，则消费者每唤醒一个生产者，sem+=1
>
> 模拟一下多个进程合作时的情况：
>
> - 缓冲区满，此时P1执行，发现已满，进入睡眠，并将sem-=1（sem = -1）
> - 调度到P2执行，发现已满，进入睡眠，sem-=1                （sem = -2）
> - 调度到C执行，发现sem = -2，唤醒P1                           (sem = -1)
> - C执行，发现sem为负数，唤醒P2                               （ sem = 0 ）
> - C执行，读取，此时sem中出现空余，sem ++                   （sem = 1）
> - 调度到P1，发现有空位，消耗sem……

## 