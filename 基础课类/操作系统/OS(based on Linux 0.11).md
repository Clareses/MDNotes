# 计算机操作系统

## 前言

在CSAPP中，已经初步了解过了编写的代码是如何一步步加载到内存中执行的

> 经过以下阶段
>
> - 编译，得到汇编代码
> - 汇编，得到目标文件
> - 链接，得到可执行文件
> - 加载，通过虚拟内存系统，将磁盘上的可执行文件按页映射入物理内存中
> - 执行，CPU从内存中读指令，并进行运算等操作

但是仍然不足以解释为什么能在屏幕上输出“Hello world”

这中间还差了一环，在输出时，我们**通过系统级调用**，向标准输出设备文件输出，而这一部分，就是由操作系统提供的

这门课的**目的就是理解操作系统如何运作，通过对上层提供接口，从而协调多种硬件共同工作**。 

## OS的启动过程

### 预备知识

#### 计算机启动过程

- 计算机在上电后，会做的第一件事就是**运行BIOS**，完成计算机内部的检查与初始化（设置一些寄存器的值等），这一过程**会将CS：IP设置为 0x07c0**，**并将磁盘中第一个扇区（每个扇区大小为512KB）读入**，这将是计算机将执行的第一个程序
- 通过汇编可以与主板上的硬件进行交互（**BIOS提供了一系列的中断操作**），用户编写的汇编代码可以通过调用中断操作硬件（操作系统也是这样协调硬件的）
- 磁盘的读取是以磁盘上的**扇区为单位进行读取**的，BIOS为磁盘读取提供了中断（INT13）

#### CPU的工作模式

CPU分为两种工作模式，**实模式与保护模式**，这两种模式之间的区别主要在于寻址方式的不同。

工作模式的选择依赖于一个**CR0寄存器**

<img src="../../_Images/image-20220515133053041.png" alt="image-20220515133053041" style="zoom:50%;" />

下面引用一些介绍

> ​		实模式出现于早期8088CPU时期。当时**由于CPU的性能有限**，一共**只有20位地址线**（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以**为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式**。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：
>
> 　　**(段基址：段偏移量)**
>
> 　  其中第一个字段是段基址，它的值是由**段寄存器**提供的(一般来说，段寄存器有6种，分别为cs，ds，ss，es，fs，gs，这几种段寄存器都有自己的特殊意义
>
> 实模式的"实"更多地体现在**其地址是真实的物理地址**。
>
> ​		随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就**引入了现在的保护模式**，实现更大空间的，更灵活也**更安全**的内存访问。
>
> ​		**在保护模式下，CPU的32条地址线全部有效**，可寻址高达4G字节的物理地址空间;  但是我们的**内存寻址方式还是得兼容老办法**(这也是没办法的，有时候是为了方便，有时候是一种无奈)，即(段基址：段偏移量)的表示方式。当然**此时CPU中的通用寄存器都要换成32位寄存器(除了段寄存器)来保证寄存器能访问所有的4GB空间**。
>
> ​		我们的**偏移值和实模式下是一样的**，就是变成了32位而已，**而段值仍旧是存放在原来16位的段寄存器中**，**但是这些段寄存器存放的却不再是段基址了**，毕竟之前说过实模式下寻址方式不安全，我们在保护模式下需要加一些限制，而这些限制可不是一个寄存器能够容纳的，于是我们**把这些关于内存段的限制信息放在一个叫做全局描述符表**(GDT)的结构里。**全局描述符表中含有一个个表项**，每一个表项称为**段描述符。**而段寄存器在保护模式下存放的便是相当于一个数组索引的东西，通过这个索引，可以找到对应的表项。段描述符存放了段基址、段界限、内存段类型属性(比如是数据段还是代码段,注意**一个段描述符只能用来定义一个内存段**)等许多属性,具体信息见下图：
>
> <img src="../../_Images/image-20220515132505570.png" alt="image-20220515132505570" style="zoom:67%;" />
>
> ​		全局描述符表位于内存中，需要用专门的寄存器指向它后， CPU 才知道它在哪里。这个专门的寄存器便是**GDTR**(一个48位的寄存器),专门用来存储 GDT 的内存地址及大小。

同样地，中断也不再是直接访问了，而是通过IDT（中断定义表）来定位到对应的中断函数（系统调用基于这个机制）

### bootsect.s

源码文件放在同一文件夹下

- BIOS执行后

![image-20220514193329533](../../_Images/image-20220514193329533.png)

- bootsect-1 复制了自己

![image-20220514193502562](../../_Images/image-20220514193502562.png)

- 读取setup

![image-20220514193835529](../../_Images/image-20220514193835529.png)

- 读system

![image-20220514194102737](../../_Images/image-20220514194102737.png)

**不难看出，bootsect只是读取了后续需要的所有文件...**

### setup.s

![image-20220515144018407](../../_Images/image-20220515144018407.png)

setup一方面通过BIOS中断读取了一些系统需要的**硬件信息**并写在0x90000开始的一段内存中（如扩展内存的大小、显卡信息、光标位置等），另一方面将0x10000～0x90000的内存复制到0x00000～0x80000，即**将system部分往前移动**。最后**开启保护模式，跳转进入system部分执行**。



### head.s

Linux makefile将head.s放置在了system部分的开头，因此setup执行后将执行这一部分

这一部分由于已经开启了保护模式，因此可以使用32bit汇编进行编程了（终于舒服了...）

**这一部分初始化了GBT表后，调用main函数，并在main中不断循环，不再退出**

![image-20220515153850090](../../_Images/image-20220515153850090.png)

进入main之前，先准备好了paging信息

进入main后，如果main发生了return，则会进入L6，开始死循环（死机）

**main中会进行一系列init，包括内存、中断、设备、时钟、CPU等**

### 总结

操作系统在启动时，主要进行的操作就是 **读系统** 与 **初始化参数**

- bootsect读入系统与setup
- setup对系统的位置做一系列整理，并获取一些参数
- head为进入系统作最后准备，加载页表等
- main加载操作系统的各个模块