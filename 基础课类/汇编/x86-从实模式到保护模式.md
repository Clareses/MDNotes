# x86汇编

## 一. 预备知识

### 信息的表示与编码

- 一个内存地址编码1byte的数据

- 一个字由高字节、低字节组成；一个双字由高字与低字组成

- intel x86指令最短仅1byte，最长可到15byte，一般由1byte opcode（操作码）与多个

  func code（功能码）、operand（操作数）构成，指令长度和译码方式由opcode指示

  （简单源于规整，还得是RISCV...）

- 大端序？小端序？记住是*按照字节来排序，而不是按位排序*的

<img src="../../_Images/image-20220728095839022.png" alt="image-20220728095839022" style="zoom:50%;" />

​	所谓大小端，即*字开始的位置*，存的是高字节还是低字节（低字节为小端，高字节为大端）

### Intel 8086处理器

#### 寄存器

| 通用寄存器(16bits) | 功能                             |
| :----------------: | -------------------------------- |
|         AX         | 通用，且支持XH、XL的高低字节访问 |
|         BX         | 通用，且支持XH、XL的高低字节访问 |
|         CX         | 通用，且支持XH、XL的高低字节访问 |
|         DX         | 通用，且支持XH、XL的高低字节访问 |
|         SI         | 源变址寄存器                     |
|         DI         | 目的变址寄存器                   |
|         BP         | 栈基址指针寄存器                 |
|         SP         | 栈顶指针寄存器                   |

| 段寄存器（16bits） | 功能                 |
| :----------------: | -------------------- |
|         CS         | 代码段寄存器         |
|         DS         | 数据段寄存器         |
|         SS         | 堆栈段寄存器         |
|         ES         | 附加（数据）段寄存器 |

#### 内存分段机制的解释

​	由于程序每次被加载进内存时，并不能保证一定是同一个位置，且管理困难（需要程序员手动管理各个分区的长度），因此8086处理器设计了分段机制用于改善这一点。

​	主要存在三个段，即 *代码段、 数据段、 堆栈段*

- 对代码段的访问由两个寄存器控制，即CS：IP，IP寄存器会指示当前执行的程序相对代码段起始（即CS寄存器中存的值）的偏移量，并随着程序执行而不断自行增加；访问代码段时，物理地址即为CS中的值以某种方式组合上IP的值
- 对数据段的访问与对堆栈段的访问相比对代码段的访问更加复杂一些，但是原理大致相同

> **某种组合方式**
>
> ​	上面提到，对物理地址的访问是由段寄存器与偏移寄存器通过某种方式组合，那么具体是什么方式呢？
>
> ​	8086提供了20根地址线，即提供了1MB的物理地址空间，而偏移寄存器的长度均为16bits，意味着最多仅能提供64KB的段，形成了极大的浪费
>
> ​	为了匹配20bits的地址空间，需要*将段寄存器左移4bit*，*再与偏移寄存器的值相加*，即可得到20bits的地址数据

​	8086提供1MB的物理地址空间，最多可以划分为16个段（段寄存器的值从0x0000到0x000F），而16个段可以根据需要自行定义成上述三种段中的任意一种。程序员在代码段超过64KB时，修改一次CS的值，即可继续下一个代码段的指令执行；对数据段、堆栈段也是如此。

​	因此，8086的内存管理甚至可以说十分随意、自由；事实上，段寄存器的值仅需要按16byte对齐即可。

## 二. 主引导扇区

### 计算机的启动过程

​	处理器在加电后，如果硬盘是首选启动设备，那么主板上的BIOS将试图读取硬盘的0面0道1扇区，这就是*主引导扇区*（Main Boot Sector，MBR）

​	一个扇区有512 byte 的空间，BIOS会将它加载到地址空间 *0x0000:0x7c00* 处，然后判断该扇区是否是合法的引导扇区（合法的引导扇区最后两个字节是固定的标识符）

​	正常来说，主引导扇区的代码由操作系统提供，会进行一些其他的读硬盘操作、加载启动内核等工作（[OS笔记](../操作系统/OS(based on Linux 0.11).md)中System setup部分介绍了Linux 0.11中主引导扇区的代码）

​	**本章节将尝试编写一段代码并写入主引导扇区，并在屏幕上完成输出**

### 显卡与显存

​	要在屏幕上进行输出，首先得理解处理器如何对IO设备（即这里的显卡）进行操作

​	显卡是介于显示器与处理器之间的一个中介，处理器可以向显存中写入内容（通过MMIO的方式，见ics-pa 4 中输入输出部分），*显卡从显存中读取信息并加工后，形成像素信息输出给屏幕*

​	*显存中的信息应如何解读，可以通过对显卡的配置进行更改*。如将显卡配置为文字模式，则显存中的信息将作为ASCII码输入显卡，经过字符发生器（显卡中的一个部件）后生成像素信息显示在屏幕上

​	对显存的访问使用MMIO（Memory Mapping IO，内存映射IO）方式，因此访问显存与访问内存没什么区别；*在文本模式下，显存的起始地址为0xB8000，可以理解为 ES 为 0xB800，偏移为 0x0000的一**段**内存*

> **对段寄存器的访问**
>
> ​	Intel处理器不允许将一个立即数直接传递到段寄存器，只允许从通用寄存器传递到段寄存器

> **mov指令**
>
> ​	mov （位宽） dst, src
>
> dst：可以是内存地址（格式为[(ds)/es:offset]）或是寄存器
>
> src：可以是内存地址或是寄存器
>
> 注：dst 与 src 不能同时为内存地址（每条指令只有一次访存操作造成此限制），位宽在寄存器之间或是确保匹配的情况下可以省略

### 代码

```assembly
   mov ax,0xb800                 ;指向文本模式的显示缓冲区
    mov es,ax
    ;以下显示字符串"L:"
    mov byte [es:0x00],'L'
    mov byte [es:0x01],0x07
    mov byte [es:0x18],':'
    mov byte [es:0x19],0x07
    mov ax,number                 ;取得标号number的偏移地址
    mov bx,10
    ;设置数据段的基地址,这里共用了数据段与代码段
    mov cx,cs
    mov ds,cx
    ;求个位上的数字
    mov dx,0
    div bx
    mov [0x7c00+number+0x00],dl   ;保存个位上的数字
    ;求十位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x01],dl   ;保存十位上的数字
    ;求百位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x02],dl   ;保存百位上的数字
    ;求千位上的数字
    xor dx,dx
    div bx
    mov [0x7c00+number+0x03],dl   ;保存千位上的数字
    ;求万位上的数字 
    xor dx,dx
    div bx
    mov [0x7c00+number+0x04],dl   ;保存万位上的数字
    ;以下用十进制显示标号的偏移地址
    mov al,[0x7c00+number+0x04]
    add al,0x30
    mov [es:0x1a],al
    mov byte [es:0x1b],0x04
    mov al,[0x7c00+number+0x03]
    add al,0x30
    mov [es:0x1c],al
    mov byte [es:0x1d],0x04
    mov al,[0x7c00+number+0x02]
    add al,0x30
    mov [es:0x1e],al
    mov byte [es:0x1f],0x04
    mov al,[0x7c00+number+0x01]
    add al,0x30
    mov [es:0x20],al
    mov byte [es:0x21],0x04
    mov al,[0x7c00+number+0x00]
    add al,0x30
    mov [es:0x22],al
    mov byte [es:0x23],0x04
    mov byte [es:0x24],'D'
    mov byte [es:0x25],0x07
      
infi: jmp near infi                 ;无限循环
      
number db 0,0,0,0,0
  
times 203 db 0 
db 0x55,0xaa
```

> **对一些指令的解释**
>
> ​	*div*：ax固定存放被除数，除数为指定寄存器中的值（上面代码中为bx(10)）
>
> ​	*db*：即define byte，用于定义数据位宽为字节，如db 0,0,0,0则表示定义4个长度为byte的数据
>
> ​	*标号*：如infi、number，本质上只是一个标识符，用以获取对应的内存地址