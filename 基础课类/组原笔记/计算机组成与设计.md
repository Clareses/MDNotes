# 计算机组成与设计

## RISC-V指令集

### 操作数

- **寄存器**，X0~X31，共32共寄存器
- **地址**，偏置(基址寄存器)，如 1000（x0）

- **立即数**

> **关于有符号与无符号**
>
> ​	RISC-V有一个特点，将在操作立即数（或是操作地址读出的值）时强制将数据扩展（Intel x86则提供了类似rax、eax、ax、lax一系列不同位数的寄存器操作符，而RISC-V只有Xn系列寄存器，并且只支持固定的位数访问）
>
> ​	因此，RISC-V对于扩展有严格的要求，需要区分是加载有符号数还是无符号数，也就有了lh（取半字）与lhu（取无符号半字）这样的操作。有符号加载与无符号加载的区别在于是选择零扩展还是符号位扩展
>
> ​	**Note： RISC-V中的立即数都是有符号的！！！**

### 指令格式

**RISC-V的每一条指令的长度都为32bit**

RISC-V的指令分为以下几个类型

#### R型

即用于**寄存器-寄存器操作**的指令

| func7  |     rs2      |     rs1      | func3  |     rd     | opcode |
| :----: | :----------: | :----------: | :----: | :--------: | :----: |
|  7bit  |     5bit     |     5bit     |  3bit  |    5bit    |  7bit  |
| 功能码 | 寄存器操作数 | 寄存器操作数 | 功能码 | 目的寄存器 | 操作码 |

例如： add x0，x1，x2	（x0 = x1 + x2）

对应的机器码为：**0000000** **00010** **00001** **000** **00000** **0110011**

#### I型

用于**短立即数和访存 load 操作**的指令

用一个7bit功能码与一个5bit寄存器操作数码，换取了一个12bit的立即数操作数

|  Imm   |     rs1      | func3  |     rd     | opcode |
| :----: | :----------: | :----: | :--------: | :----: |
| 12bit  |     5bit     |  3bit  |    5bit    |  7bit  |
| 立即数 | 寄存器操作数 | 功能码 | 目的寄存器 | 操作码 |

如： addi x0，x1，1  （x0 = x1 + 1）

#### S型

用于**访存store操作**的指令

| Imm [11：5] |     rs2      |     rs1      | func3  | Imm [4：0]  | opcode |
| :---------: | :----------: | :----------: | :----: | :---------: | :----: |
|    7bit     |     5bit     |     5bit     |  3bit  |    5bit     |  7bit  |
| 立即数高7位 | 寄存器操作数 | 寄存器操作数 | 功能码 | 立即数低5位 | 操作码 |

与I型对比，发现虽然都是12bit的Imm和2个5bit寄存器，但是结构并不一样

**观察发现，RSIC-V对寄存器的位置安排非常严格，寄存器rd作为目的寄存器，rs1与rs2作为参数寄存器，一定在对应的那些位置，宁愿把Imm分割成两部分也要保证寄存器的位置正确**

**因此，S型是store类型，不需要rd，所以rd的5bit被用于补充Imm的低位了**

#### 其余的

**除上面的内容外，还有用于条件跳转操作的 B 类型指令，用于长立即数的 U 型指令和用于无条件跳转的 J 型指令**

### 逻辑操作指令

| 逻辑操作 |      RISC-V指令       |
| :------: | :-------------------: |
|   左移   |       sll  slli       |
|   右移   |       srl  srli       |
| 算术右移 |       sra  srai       |
|  按位与  |       and  andi       |
|  按位或  |        or  ori        |
| 按位异或 |       xor  xori       |
| 按位取反 | xori（对1111...异或） |

其中，对于R型指令，都是一样的

但是对于I型指令，由于2^12^远大于63，而位移大于63位的值完全没什么意义，因此在逻辑操作时，产生了I型指令的变体

| func6 | Imm  | rs1  | func3 | rd   | opcode |
| ----- | ---- | ---- | ----- | ---- | ------ |
| 6bit  | 6bit | 5bit | 3bit  | 5bit | 7bit   |

### 分支操作指令

|          操作          |    RISC-V指令     |
| :--------------------: | :---------------: |
|       等于时跳转       | beq rs1 , rs2 , L |
|      不等于时跳转      | bne rs1 , rs2 , L |
|       小于时跳转       |        blt        |
|     大于等于时跳转     |        bge        |
| 小于时跳转（unsigned） |       bltu        |
| 大于时跳转（unsigned） |       bgeu        |

猜测意思应该是...branch equal和branch not equal叭

还有需要注意的时，比较有分有符号和无符号两种（话说x86里怎么没什么印象...）

### 循环、分支、Switch

循环、分支只是基于跳转指令的一个常规操作，没什么可说的

Switch是在内存中使用一个数组专门存储了每个跳转的位置，并在条件满足时把数据从内存中加载到寄存器实现跳转

### 过程调用

#### 一些基本约定

- **[X10 , X17]**这部分寄存器用来依次保存调用时的八个参数
- **X1**用于保存返回地址，用于跳转后返回起点
- **X2**是栈指针，相当于%rsp
- **[X5 , X7] , [X28 , X31]**为**临时寄存器**，在过程调用中应该为**调用者保存**
- [X8 , X9] , 