# 计算机网络

## 一、概论

在这一章节中，主要介绍计算机网络的模型，以及在计算机网络中探讨的一些术语

### 计算机网络五层模型

|         层次（从高到低）         | 功能                                                         |
| :------------------------------: | :----------------------------------------------------------- |
| **应用层**（如HTTP、FTP、DNS等） | 这部分协议的功能是**服务于具体的网络应用**的，如HTTP规范的是web程序交互的格式（请求与响应的格式等） |
|      **传输层**（TCP、UDP）      | 这部分协议的功能是在网络层实现端到端通信的基础上**实现host中具体进程间的通信**，TCP协议还同时保证了通信的可靠性 |
|         **网络层**（IP）         | 在链路层的基础上，实现了**端到端通信**                       |
|  **链路层**（以太网协议、WIFI）  | 实现了**相邻的点到点通信**                                   |
|            **物理层**            | 数模转换，将媒体中的数模信号进行互相转换                     |

### 互联网的结构

**Internet = Edge + Access + Core**

#### 互联网边缘

由**端系统**（host，或称为主机）构成，它们是互联网最外层次的端点，作为信息源

#### 接入网

接入网是一些链路，从端点出发并通过连接到ISP而接入到互联网核心

#### 互联网核心

由大量的交换机、路由器构成，它们作为计算机网络的中间节点，并不提供信息，只负责将信息转发到对应的端点（边缘）

### 交换方式

#### 电路（线路）交换

类似于电话线，通过建立一个稳定的、专用的连接从而实现端到端的通信。但是与计算机网络的实际情况并不吻合

- 计算机网络通常并不连续通信，而具有**突发性、短暂性**，使得建立、维护连接的时间开销相对大
- 计算机网络庞大而复杂，维护连接的难度很大
- 计算机网络的端点极多，线路交换这种专有的通信**容易阻塞**

#### 分组交换

是现有计算机网络体系所采取的交换方式。采用存储转发传输，通过发送PDU（协议数据单元），并在路由处排队转发，从而实现网络链路的尽可能的共享。但是也同样带来了一些负面的因素

#### 分组交换的缺陷

- **时延** 
	- 分组交换采取存储转发的方式，因此每次转发前都必须等上一个节点将所有的分组都发送完全后，才往下一个节点进行转发。这一段时间被称为**传输时延**，即发送/接收需要的时间
	- 每个中间节点接收到完整的分组后，都需要进行一些固定的操作（比如解封装获取目的ip、验证校验位等），这部分花费的时间称为**处理时延**
	- 分组到达中间节点并找到对应端口准备发送时，如果对应端口上还有未发送完的分组，那么需要在缓冲区内排队等候，即**排队时延**
	- 分组从节点发出到链路上后，需要一定时间才能到达下一个节点，这部分由电磁波及媒介的物理性质决定的时延称为**传播时延**
- **丢包**
	- 如果进入转发端口时，该端口的缓冲区已经满了，那么该数据包会被直接丢弃，即发生了丢包。因此，在网络层（IP协议）直接进行的通信的不具备可靠性的，需要更高层的协议提供保障

### 一些零散的知识点

#### 路由器与交换机

路由器的功能在于路由，它工作于网络层，能够通过IP协议转发信号。因此当一个媒体信号到达路由器时，会先向上解封装到网络层，再从发射端口封装到物理层

交换机的功能在于连接多个端点，工作于链路层，并不区分不同IP的转发，而是无条件向所有端口转发，因此只需要解封装到链路层

#### ISP层次

**ISP**，即Internet Service Provider，网络服务提供商

最初的ISP一般只能负责到一定区域内，因此出现了想专门在大范围内提供互联服务的全球ISP（Global ISP），但是由于竞争出现了多家全球ISP，它们之间进行合作，通过IXP这样的公益组织互联，并提供服务给下一层次的ISP（region ISP，地区ISP），最后达成了全球互联的现状

#### PDU

PDU，即**协议数据单元**，是同层协议之间进行数据交换的基本单位。不同协议的PDU有着不同的规范和名称。

- **应用层 -- 报文（Message）**

- **传输层 -- 报文段（Message Segment）**
- **网络层 -- 数据报（Datagram）**
- **链路层 -- 帧（frame）**

#### 协议与服务

在计算机网络的层次结构中，下层协议通过SAP（SERVICE ACCESS POINT，类似于接口）向上层协议提供服务（SERVICE）。协议是计算机网络中同一层次的部分进行交互的规范，服务是下层协议对上层协议的支持。

## 二、应用层

### 应用层协议原理

#### Socket原理

在调用系统调用Socket之后，操作系统会根据参数建立一个Socket，并返回一个描述符

Socket可以描述一个连接（尤其是对于TCP等面向连接的传输层协议来说）

Socket的基本目的就是，**减少从应用层通过SAP到传输层的数据量**

如果没有Socket，那么每次要进行传输的数据是：

- 对TCP而言，四元组（host，port，host，port）
- 对UDP而言，二元组（host，port）

而使用Socket之后，操作系统会为连接建立一个**本地**的Socket表，记录Socket描述符与对应的数据，这样从应用层流向传输层的数据量大大减小（只用一个描述符就可以找到对应的连接）

ps：很典型的时间（查表时间）换空间（传输数据量）呢~

#### 传输层协议的选取

- 对于**可靠性要求高**的---TCP
- 对于**时间敏感**的---UDP

- **安全性**---TCP的改良版本，SSL

#### 应用层协议的一点思考

在计算机网络的各种协议中，应用层协议是最多的，并且也是最“软”的

因为它只规定了网络应用程序之间如何交换信息...而如果你的服务器和客户端并没有公共需求的话...

ps：公共需求就是说同类型的客户端或者同类型的服务器都可以访问

那你完全可以搞一个自己专用的“私有协议”...事实上很多公司已经这么干了...

在应用层中，只是浅浅了解一些协议的规范，仅此而已

（比如所有的web客户端（浏览器）都可以访问所有的web服务器（不管它是哪家公司的）...）

### HTTP协议

#### WEB原理

Web很大程度依赖于HTML这一“超文本描述语言”

HTML最好的地方就是，可以互相连接

因此在Web应用中，常常有一个“**HTML基本文件（Base HTML）**”，HTML基本文件中又包含了多个链接到其他文件的超链接

浏览器在接收到HTML基文件后，绘出基本框架，再向服务器请求基本文件中包含的其他文件，继续绘制到页面上

**HTTP协议需要至少三次握手，第一次是C发出TCP连接请求，第二次是S发出连接响应，第三次是C发出请求报文**

#### 持续性连接与非持续性连接

- **持续性连接**  在TCP连接建立后可以处理多条请求，并可以设置一段时间内没有收到请求则关闭连接
- **非持续性连接**  每个TCP连接只接收一个请求，响应后立马断开

**注** HTTP/1.0只支持非持续性连接，**HTTP/1.1可以设置连接方式，通过请求头Connection: close/keep-alive**

#### 报文的结构

行 + 多个头 + 空行 + 实体体

##### 对请求而言

**请求行**：**[method url version]**  如：GET  /  HTTP/1.0

-  **method（请求方法）**

> - **GET** 一般请求，没有实体体（也可以在URL中加入请求参数）
> - **POST** 提交请求，一般将提交内容放在实体体里
> - **HEAD** 与GET一致，但是服务器只返回响应头而不放回实体体（debug用）
> - **PUT** 上传请求
> - **DELETE** 删除请求，要求删除url位置的内容

**请求头**：**[param: value]** 如：Connection: close

> - **Host** 标识访问的主机（在代理服务器中有用）
> - **Connection** 选择持续连接或非持续连接
> - **User-agent** 客户端浏览器类型
> - **Accept-language** 客户端语言类型

##### 对响应而言

**响应行** ：**[version status-code short-message]**，具体规则见[CSAPP笔记](../计算机体系/CMU 15-213 CSAPP.md)

**响应头**：**[param: value]**

> - **Connection** 连接类型
> - **Date** 该报文的发送时间
> - **Server** 服务器软件类型
> - **Last-Modified** 该文件最后修改时间
> - **Content-Length** 响应体长度
> - **Content-Type** 响应体文件类型

#### Cookie

Cookie是一种机制，由Server分配，并由浏览器本地维护，这样即可根据Server在后端维护的cookie表在http协议上建立一个**状态层**，记录用户的行为。

<img src="../../_Images/image-20220409090108917.png" alt="image-20220409090108917" style="zoom:67%;" />

#### WEB缓存

还记得在硬件中学过的计算机缓存吗？

WEB应用中同样有这样的机制——用一台"**缓存服务器**"或者叫做"**代理服务器**"即可实现

WEB缓存的**根本目的**是**减少接入链路的压力**，每台机构网络内部的计算机访问**初始服务器**时，都先请求一下机构**缓存器**，这样带来的好处是，并不是所有流量都流向接入链路，而是根据缓存器的命中概率减少。

（比如命中概率是50%，那么接入链路的压力就减小了50%！）

因此**在接入链路带宽太窄而导致的延迟情况下，比起物理增大带宽，增加一个缓存服务器是更好的选择**！

在计算机的物理缓存中，存在着多种读写机制（换取块的算法、写回/直写策略等），但在WEB缓存器这里，就无法做到类似的机制了（因为对服务器的请求来自各种地方，并不是都经过该缓存器，就是这一点不同导致了它无法和计算机存储结构一样工作），因此增加了一个**条件GET**方式，来**记录是否需要更新"块"**，条件GET就是在请求头中多加一个 **If-modified-since**请求头，这样服务器就可以根据请求头中的信息（包含最后一次更新时间）决定是否要发送更新版本的实体体了

> 那么，**WEB缓存**与我们上文中提到的**请求头中的host**有什么关系呢？很明显，给缓存服务器用的嘛~！不然缓存服务器怎么去找对应主机嘞！

### SMTP

**异步通讯，即两方不需要同时在线也可以完成交互工作**

换句话说，就是电子邮件啦

很明显其中需要服务器的参与，毕竟肯定要有个什么东西一直在线

问题那么需要多少台服务器呢？如果只有一台服务器，那么交流就只能在这台服务器下的客户可以进行交流

而邮件系统是不受这种限制的（QQ邮箱也可以发到网易邮箱）

所以，肯定有许多台一直保持在线的服务器

这些服务器之间进行交互的协议，就是**SMTP（simple mail transfer protocol）**

#### 邮件交互的原理

个人的主机上有邮件客户端，邮件客户端通过与邮件服务器交互（可以通过SMTP也可以通过HTTP等其他协议）将报文交给邮件服务器（一般包含发件方和收件方的地址加上报文）

邮件服务器接收到客户端传来的数据后，将报文放入邮件队列中，用SMTP报文向另一台邮件服务器发送信息

另一台邮件服务器接收后将根据报文信息将邮件整入维护的用户邮箱中（每个用户都有一个喔）

用户再用客户端拉去邮箱里的邮件（可以通过很多协议（HTTP、POP3、IMAP等））

#### SMTP简介

SMTP协议是一个**基于TCP的**、**持续连接的**应用层协议

SMTP服务器交互的过程为

- TCP连接
- 握手（传递信息）
- 传送（发送报文）
- 如果还有报文，则再握手传送
- 没有报文则关闭连接

因此一个TCP连接可以传输多条报文，是持续连接的协议

#### SMTP握手

- Client: HELO xxx
- Server: 250 + message
- Client: MAIL FROM: <ADDRESS>
- Server: 250 + message
- Client: RCPT TO: <ADDRESS>
- Server: 250 + message
- Client: DATA
- Server: 354 + message
- Client: （报文信息，以\r\n.\r\n结尾）
	- xxxxxxxxxxxxxx
	- xxxxxx
	- .
- Server: 250
- Client: QUIT
- Server: 221

可以看到SMTP握手过程中传输了邮件的来源和去路，握手结束后再输入报文

#### SMTP报文格式

> //首部
>
> From: Address
>
> To: Address
>
> Subject: xxxxxx
>
> //空行，首部和报文体的分隔
>
> Content

#### 与HTTP协议的对比

- SMTP是一个推协议，而HTTP是拉协议（SMTP的连接发起方是发送数据的一方，而HTTP是客户端，即拉取数据的一方）
- SMTP强制要求用7-bit ASCII码格式编码报文
- SMTP把所有对象都编码后放入同一个报文中（包括图片、视频等），而HTTP采用链接的方式另外拉取（得益于HTML）

### DNS（域名系统）

DNS是一个**由分层的DNS服务器实现的分布式数据库**，同时是一个使得主机能够查询该数据库的**应用层协议**，运行在**UDP**之上，使用**53号端口**

#### DNS提供的服务内容

- **IP与域名之间的转换**
- 主机映射多个域名（主机别名）
- 邮件服务器别名
- **域名映射多个主机（负载分配）**

#### DNS服务原理

- DNS是由很多DNS服务器组成的，大体分为**根DNS服务器、顶级域DNS服务器（TLD）、权威DNS服务器**
- 每个ISP都有自己的**本地DNS服务器**，用来作缓存与查询

查询过程：

1. 主机向本地DNS服务器发起请求
2. 本地DNS向根服务器发起请求，得到TLD的IP
3. 本地DNS向TLD发起请求，得到权威DNS服务器的地址
4. 本地DNS向权威DNS请求，得到主机发起请求的IP
5. 向主机返回IP

可以看到，过程极为繁琐，好在有DNS缓存这种东西，存储了一段时间内的DNS查询的记录结果，大大减少了查询的复杂度

**ps：如果有多台本地DNS服务器，将在本地DNS范围内采用递归查询，反之迭代查询**

#### DNS记录

域名与IP的映射记录在DNS条目（资源记录（RR））中，格式如下

（Name，Value， Type， TTL）

**Name是域名**

**Value是IP**

**Type是类型说明**

TTL是有效截止时间（超过TTL，服务器将删除该条缓存记录）

| Type | Name | Value            |
| ----- | |---------------- |
| **A** | **主机域名** |**域名对应的IP地址** |
| **NS** | **域** | **能查询到该域的权威DNS的IP** |
| CNAME| 主机别名 | 主机规范名 |
| MX    | 邮件服务器别名 | 邮件服务器规范名 |

#### DNS报文

```
  DNS format

  +--+--+--+--+--+--+--+
  |        Header      |	头部，12byte
  +--+--+--+--+--+--+--+
  |      Question      |	问题区域
  +--+--+--+--+--+--+--+
  |      Answer        | 	回答区域
  +--+--+--+--+--+--+--+
  |      Authority     |	权威区域包含其他权威服务器的记录
  +--+--+--+--+--+--+--+
  |      Additional    |	附加区域包含额外信息
  +--+--+--+--+--+--+--+

```

```
  Header format 头部格式

    0  1  2  3  4  5  6  7  0  1  2  3  4  5  6  7
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                      ID                       |	ID，由客户生成，作为标识符
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |QR|  opcode   |AA|TC|RD|RA|   Z    |   RCODE   |	标志，存某些设定
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    QDCOUNT                    |	问题数
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    ANCOUNT                    |	回答数
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    NSCOUNT                    |	权威RR数
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    ARCOUNT                    |	附加RR数
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  
```

> 对标志的一些解释
>
> - QR 标识是请求还是响应
> - opcode标识查询方式
> - AA标识授权回答（由服务器设置）
> - TC标识报文已经被截断
> - RD表示期望递归
> - RA标识是否支持递归查询
> - Z是保留值，还没用
> - RCode为0标识查询没有出错，否则为错误码

```
  Question format 问题部分格式

    0  1  2  3  4  5  6  7  0  1  2  3  4  5  6  7
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                     ...                       |
  |                    QNAME                      |  域名
  |                     ...                       |
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    QTYPE                      |	协议类型
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    QCLASS                     |	查询的类
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

```

```
  Answer/Authority/Additional format 响应\权威\附加部分格式

    0  1  2  3  4  5  6  7  0  1  2  3  4  5  6  7
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    NAME                       | 资源记录包含的域名
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    TYPE                       |	DNS协议的类型
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    CLASS                      |	RDATA的类
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    TTL                        |	记录可以缓存的时间
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    RDLENGTH                   |	RDLENGTH记录RD的长度
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
  |                    RDATA                      | 表示记录，根据类型来定
  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+


```

