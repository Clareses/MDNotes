# 软工导论

## 一、数制

### 数字系统

​	数字系统（数码系统），定义了如何**用一个有限的符号集来表示一个数**。在不同的数字系统中，同样的数有不同的表示方式。

#### 位置化数字系统

​	位置化数字系统，符号表示的值根据其位置而变化。这种系统中，数字这样表示（其中b为底）：
$$
\pm(S_{k-1}S_{k-2}...S_{k-i})_b
$$
​	其值为：

​	
$$
n=\pm S_{k-1}\times b^{k-1}+S_{k-2}\times b^{k-2}....+S_{k-i}\times b^{k-i}
$$
​	常用的十进制、八进制、十六进制等就是底为10、8、16的位置化数字系统。

#### 非位置化数字系统

​	一个常见的例子是罗马数字。它使用符号的位置关系（而不是位置）来决定表示的数。如IV是 5 - 1 = 4， VI 是 5 + 1 = 6 ... 不重要，知道即可。

>   ​	本章掌握以上基本概念，会**进制转换**即可



### 整数的二进制编码

#### 无符号

​	原码，即所有二进制位都为正权的二进制编码方式，无符号数采用这种方式表示。

#### 有符号

​	有符号数有两种表示方法：

-   符号加绝对值表示法，即将最高位作为符号位，剩余位表示数的绝对值。
-   补码表示，将原码的最高位改为负权。

>   **补码的优势**
>
>   ​	运算规律与原码的体系完全一致，且表示的范围较符号加绝对值的更大（符号加绝对值表示会有两种0，正0和负0）



### 浮点数

#### 一般表示

浮点数一般采用这样的结构表示
$$
(S_kS_{k-1}...S_0.S_{-1}...S_{-m})_b\times b^n
$$
如： 101.11 * 2^2^ = 10111b

问题在于这样的浮点数可以有多种表示方式（将小数点前后移再改变n即可）

#### 规格化浮点数

​	为了规范表示浮点数，引入规格化浮点数机制。即**如果尾数不为0，则其最高位必须为1**，如上面例子中的数用规格化浮点数表示应为1.0111 * 2^4^。

#### IEEE浮点数

| 宽度 | 符号 | 阶码 | 尾数 |
| :--: | :--: | :--: | :--: |
|  32  |  1   |  8   |  23  |
|  64  |  1   |  10  |  51  |

注：

-   IEEE浮点数尾数前默认带一位固定的1
-   IEEE浮点数的阶码采用移码计算，表示范围为 -2^n-1^ +1 ~ 2^n-1^

例：

​	
$$
1-10101010-10101010101010101010101010
$$

-   符号位为1，负
-   阶码为 43
-   尾数为 1.101010101010101010b （添上隐含的1）
-   表示的数为 1.101010101010101010b*2^43^（小数点向右移动43位）

>   非规格化的IEEE浮点数
>
>   -   如果阶码全为0，则取消隐含的1
>   -   如果阶码全为1，且尾数全为0，则表示正负无穷
>   -   如果阶码全为1，尾数不全为0，说明NAN（Not a Num）



### 运算

>   会算就行，转换来转换去然后位运算、数学运算、逻辑运算...

## 二、计算机网络

### 几个概念

-   端系统：网络终点的设备，是网络通信最初的发送方或是最后的接收方
-   网络核心：由一系列交换机和路由器构成，端系统发出的分组在网络核心经过多次中转到达另一个端系统
-   路由器：网络层设备，通过IP完成端到端通信
-   交换机：链路层设备，通过MAC协议完成点到点通信

-   点分十进制：IP地址的表示方式，使用4个0-255之间的十进制表示32位二进制，每个十进制之间用.分开

### 协议栈

​	计算机网络由以下协议构成

-   **应用层协议**：各个联网程序之间通讯的约定，比如HTTP协议、SMTP协议等。（应用对每个字段的含义、一些行为该如何处理的约定）分为公有协议和私有协议，公有协议一般是一类软件为了互相通信而约定的协议（比如http协议，浏览器和web服务器软件大都根据它的规范实现），而私有协议不公开，一般自个偷着用...（比如一些专有软件和服务器之间通信...）
-   应用层以下是**传输层协议**，常见的有TCP、UDP等，它们实现的功能主要是**建立在端到端通信上的多路复用**。端系统上一般运行多个程序，那么传输来的分组应该给哪个程序？这部分工作由传输层协议来完成（通过对每个程序分配端口）。此外，传输层协议还有可能实现可靠传输之类的附加功能。

-   **网络层**，如IP协议（网际协议），完成端到端通信。（IP协议）通过IP地址标识出唯一的网络设备，将分组带上IP交给网络层，网络层会将分组送到对应的端系统。**端到端通信建立在点到点通信之上**，通过多次点到点通信完成端到端通信。
-   **链路层**，在网络层之下作为支撑，在局域网内完成点到点通信，使用唯一的MAC地址（物理地址），寻找到与自己直接相连的网络设备并进行转发。
-   **物理层**，在链路层之下，约定了两个直接相连的网络设备之间的信息交换方式。（比如互相发送内容的频率、编码格式等）。

>   **使用浏览器访问网页**
>
>   -   浏览器将应用层报文生成（请求的内容等）并交给传输层
>   -   传输层将应用层报文和端口号等组装成传输层报文，并交给网络层
>   -   网络层将IP等信息加上，交给链路层
>   -   链路层加上MAC地址信息，通过物理层发送到另一个链路层设备（交换机）
>   -   交换机接收到分组，解析链路层报文，修改链路层报文，并交给下一个点（假设是路由器）
>   -   路由器同样对报文一层一层解析（从下往上），解析到网络层后，通过IP确定下一跳的IP地址，再往下层层封装，通过物理层发出...
>   -   最后服务器通过物理链路接收到报文，向上解析到应用层，通过应用层协议解析出请求的内容，进行处理后将回应的报文发回到请求端

## 三、算法

### 算法的定义

>   算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰 指令 ，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的 输入 ，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用 空间复杂度 与 时间复杂度 来衡量。算法中的指令描述的是一个 计算 ，当其 运行 时能从一个初始状态和（可能为空的）初始输入开始，经过一系列 有限 而清晰定义的状态，最终产生 输出 并 停止 于一个终态。一个状态到另一个状态的转移不一定是确定的。

### 结构化程序设计

三种基本结构： 顺序、循环、选择

### 伪代码

没有统一规范，看得懂就行。

## 四、数据库

### SQL

​	关系型数据库的组织结构为：每个数据库下，有多张表，每张表下有多个行，每行有多个相关的字段

表大概如下：

| 字段1 | 字段2 | 字段3 | 字段4 |
| ----- | ----- | ----- | ----- |
| 行1   | 行1   | 行1   | 行1   |
| 行2   | 行2   | 行2   | 行2   |

### SQL语句

```sql
#选择子句
SELECT (DISTINCT) <dataname> or *（代表所有data） 
FROM  <tablename>  (WHERE  <condition>)  
(ORDER BY  <dataname> (DESC))  (LIMIT  (<offset> ,)  <lines> )

#表更新
UPDATE <tablename> SET <columnname> = <newvalue> (where <condition>)
```

### 数据库设计范式

#### 第一范式

​	数据表中所有字段都是不可分割的原子值。数据表的每一列都要保持它的**原子特性**，也就是列不能再被分割。

#### 第二范式

​	属性必须完全依赖于主键。

#### 第三范式

​	必须满足第二范式的基础上，所有的非主属性不依赖于其他的非主属性。